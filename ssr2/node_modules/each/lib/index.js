// Generated by CoffeeScript 2.2.4
/*
Each is an async iterator encapsultated in one elegant function. The execution
can be controlled over multiple functions accessible as a chained API.

each(elements)
.parallel(false|true|integer)
.sync(false)
.times(1)
.repeat(1)
.push(element)
.unshift(element)
.write(element)
.pause()
.resume()
.close()
.call(callback)
.error(callback)
.next(callback)
*/
var Each;

Each = function(_elements, options = {}) {
  var isObject, type;
  this._elements = _elements;
  this.options = options;
  // @options, 
  // Arguments
  // if arguments.length is 1
  //   @_elements = @options
  //   @options = {}
  this.options.concurrency = 1;
  this.options.repeat = false;
  this.options.sync = false;
  this.options.times = 1;
  // Internal state
  type = typeof this._elements;
  if (this._elements === null || type === 'undefined') {
    this._elements = [];
  } else if (type === 'number' || type === 'string' || type === 'function' || type === 'boolean') {
    this._elements = [this._elements];
  } else if (!Array.isArray(this._elements)) {
    isObject = true;
  }
  if (isObject) {
    this._keys = Object.keys(this._elements);
  }
  this._errors = [];
  this._close = false;
  this._endable = 1;
  this._listeners = [];
  // Public state
  this.total = this._keys ? this._keys.length : this._elements.length;
  this.started = 0;
  this.done = 0;
  this.paused = 0;
  this.readable = true;
  setImmediate(() => {
    return this._run();
  });
  return this;
};

Each.prototype._has_next_handler = function() {
  var ref;
  return ((ref = this._listeners[0]) != null ? ref[0] : void 0) === 'call';
};

Each.prototype._get_current_handler = function() {
  var ref;
  if (((ref = this._listeners[0]) != null ? ref[0] : void 0) !== 'call') {
    throw Error('No Found Handler');
  }
  return this._listeners[0][1];
};

Each.prototype._call_next = function(error, count) {
  var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;
  if (error) {
    while ((ref = (ref1 = this._listeners[0]) != null ? ref1[0] : void 0) !== 'error' && ref !== 'next' && ref !== 'promise') {
      this._listeners.shift();
    }
  }
  if (((ref2 = this._listeners[0]) != null ? ref2[0] : void 0) === 'error') {
    if (error) {
      this._listeners[0][1].call(null, error);
    }
    if (((ref3 = this._listeners[1]) != null ? ref3[0] : void 0) === 'next') {
      this._listeners.shift();
      if (!error) {
        if ((ref4 = this._listeners[0]) != null) {
          ref4[1].call(null, count);
        }
      }
    } else if (((ref5 = this._listeners[1]) != null ? ref5[0] : void 0) === 'promise') {
      this._listeners[1][1].resolve.call(null);
    }
    return;
  }
  if (((ref6 = this._listeners[0]) != null ? ref6[0] : void 0) === 'next') {
    this._listeners[0][1].call(null, error, count);
    if (((ref7 = this._listeners[1]) != null ? ref7[0] : void 0) === 'promise') {
      this._listeners[1][1].resolve.call(null);
    }
    return;
  }
  if (((ref8 = this._listeners[0]) != null ? ref8[0] : void 0) === 'promise') {
    if (error) {
      this._listeners[0][1].reject.call(null, error);
    } else {
      this._listeners[0][1].resolve.call(null);
    }
    return;
  }
  throw Error('Invalid State: error or next not defined');
};

Each.prototype._run = function() {
  var args, err, error, handler, handlers, i, index, j, l, len;
  if (this.paused) {
    return;
  }
  if (!this._errors.length) {
    handlers = this._get_current_handler();
  }
  // This is the end
  error = null;
  if (this._endable === 1 && (this._close || (handlers && this.done === this.total * this.options.times * handlers.length) || (this._errors.length && this.started === this.done))) {
    this._listeners.shift();
    if (this._errors.length || !this._has_next_handler()) {
      // Give a chance for end to be called multiple times
      this.readable = false;
      if (this._errors.length) {
        if (this.options.concurrency !== 1) {
          if (this._errors.length === 1) {
            error = this._errors[0];
          } else {
            error = new Error(`Multiple errors (${this._errors.length})`);
            error.errors = this._errors;
          }
        } else {
          error = this._errors[0];
        }
      } else {
        args = [];
      }
      this._call_next(error, this.done);
      return;
    }
    handlers = this._get_current_handler();
    this._endable = 1;
    this.started = 0;
    this.done = 0;
    this.paused = 0;
    this.readable = true;
  }
  if (this._errors.length !== 0) {
    return;
  }
  while ((this.options.concurrency === true ? (this.total * this.options.times * handlers.length - this.started) > 0 : Math.min(this.options.concurrency - this.started + this.done, this.total * this.options.times * handlers.length - this.started))) {
    if (this._errors.length !== 0) {
      // Stop on synchronously sent error
      break;
    }
    if (this._close) {
      break;
    }
    // Time to call our iterator
    if (this.options.repeat) {
      index = this.started % this._elements.length;
    } else {
      index = Math.floor(this.started / (this.options.times * handlers.length));
    }
    this.started += handlers.length;
    try {
      for (i = j = 0, len = handlers.length; j < len; i = ++j) {
        handler = handlers[i];
        l = handler.length;
        if (this.options.sync) {
          l++;
        }
        switch (l) {
          case 1:
            args = [];
            break;
          case 2:
            if (this._keys) {
              args = [this._elements[this._keys[index]]];
            } else {
              args = [this._elements[index]];
            }
            break;
          case 3:
            if (this._keys) {
              args = [this._keys[index], this._elements[this._keys[index]]];
            } else {
              args = [this._elements[index], index];
            }
            break;
          case 4:
            if (this._keys) {
              args = [this._keys[index], this._elements[this._keys[index]], index];
            } else {
              return this._next(new Error('Invalid arguments in item callback'));
            }
            break;
          default:
            return this._next(new Error('Invalid arguments in item callback'));
        }
        if (!this.options.sync) {
          args.push((() => {
            var count;
            count = 0;
            return (err) => {
              if (err) {
                return this._next(err);
              }
              if (++count !== 1) {
                err = new Error('Multiple call detected');
                if (this.readable) {
                  return this._next(err);
                } else {
                  throw err;
                }
              }
              return this._next();
            };
          })());
        }
        err = handler(...args);
        if (this.options.sync) {
          this._next(err);
        }
      }
    } catch (error1) {
      err = error1;
      // prevent next to be called if an error occurend inside the
      // error, end or both callbacks
      if (this.readable) {
        this._next(err);
      } else {
        throw err;
      }
    }
  }
  return null;
};

Each.prototype._next = function(err) {
  if ((err != null) && err instanceof Error) {
    this._errors.push(err);
  }
  this.done++;
  return this._run();
};

Each.prototype.run = function(callback) {
  console.log('DEPRECATED: use `call` instead of `run`');
  return this.call(callback);
};

Each.prototype.call = function(callback) {
  if (!Array.isArray(callback)) {
    callback = [callback];
  }
  this._listeners.push(['call', callback]);
  return this;
};

Each.prototype.promise = function() {
  var deferred, promise;
  deferred = {};
  promise = new Promise(function(resolve, reject) {
    deferred.resolve = resolve;
    return deferred.reject = reject;
  });
  this._listeners.push(['promise', deferred]);
  return promise;
};

Each.prototype.next = function(callback) {
  this._listeners.push(['next', callback]);
  return this;
};

Each.prototype.end = function(callback) {
  this._listeners.push(['end', callback]);
  return this;
};

Each.prototype.error = function(callback) {
  this._listeners.push(['error', callback]);
  return this;
};

Each.prototype.end = function() {
  console.log('Function `end` deprecated, use `close` instead.');
  return this.close();
};

Each.prototype.close = function() {
  this._close = true;
  this._next();
  return this;
};

Each.prototype.sync = function(s) {
  this.options.sync = (s != null) || true;
  return this;
};

Each.prototype.repeat = function(t) {
  this.options.repeat = true;
  this.options.times = t;
  if (this._elements.length === 0) {
    this.write(null);
  }
  return this;
};

Each.prototype.times = function(t) {
  this.options.times = t;
  if (this._elements.length === 0) {
    this.write(null);
  }
  return this;
};

Each.prototype.files = function(base, pattern) {
  throw Error("Depracated API: each.files");
};

Each.prototype.write = Each.prototype.push = function(item) {
  var l;
  l = arguments.length;
  if (l === 1) {
    this._elements.push(arguments[0]);
  } else if (l === 2) {
    if (!this._keys) {
      this._keys = [];
    }
    this._keys.push(arguments[0]);
    this._elements[arguments[0]] = arguments[1];
  }
  this.total++;
  return this;
};

Each.prototype.unshift = function(item) {
  var index, l;
  l = arguments.length;
  if (this.options.repeat) {
    index = this.started % this._elements.length;
  } else {
    index = Math.floor(this.started / this.options.times);
  }
  if (l === 1) {
    this._elements.splice(index, 0, arguments[0]);
  } else if (l === 2) {
    if (!this._keys) {
      this._keys = [];
    }
    this._keys.splice(index, 0, arguments[0]);
    this._elements[arguments[0]] = arguments[1];
  }
  this.total++;
  return this;
};

Each.prototype.pause = function() {
  return this.paused++;
};

Each.prototype.resume = function() {
  this.paused--;
  return this._run();
};

Each.prototype.parallel = function(mode) {
  // Concurrent
  if (typeof mode === 'number') {
    this.options.concurrency = mode;
  // Parallel
  } else if (mode) {
    this.options.concurrency = mode;
  } else {
    // Sequential (in case parallel is called multiple times)
    this.options.concurrency = 1;
  }
  return this;
};

module.exports = function(elements) {
  return new Each(elements);
};

module.exports.Each = Each;
